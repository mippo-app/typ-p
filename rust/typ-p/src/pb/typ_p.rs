// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DateTime {
    #[prost(int32, tag = "1")]
    pub year: i32,
    #[prost(int32, tag = "2")]
    pub month: i32,
    #[prost(int32, tag = "3")]
    pub day: i32,
    #[prost(int32, tag = "4")]
    pub hour: i32,
    #[prost(int32, tag = "5")]
    pub minute: i32,
    #[prost(int32, tag = "6")]
    pub second: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DateDelta {
    #[prost(int32, tag = "1")]
    pub year: i32,
    #[prost(int32, tag = "2")]
    pub month: i32,
    #[prost(int32, tag = "3")]
    pub week: i32,
    #[prost(int32, tag = "4")]
    pub day: i32,
}
/// 22bit // 13 + 4 + 5
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Date {
    #[prost(fixed32, tag = "1")]
    pub value: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DateRange {
    #[prost(message, optional, tag = "1")]
    pub date_from: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2")]
    pub date_to: ::core::option::Option<Date>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Number {
    #[prost(oneof = "number::ValueOf", tags = "1, 2, 3, 4")]
    pub value_of: ::core::option::Option<number::ValueOf>,
}
/// Nested message and enum types in `number`.
pub mod number {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ValueOf {
        #[prost(int32, tag = "1")]
        Int32Value(i32),
        #[prost(int64, tag = "2")]
        Int64Value(i64),
        #[prost(float, tag = "3")]
        FloatValue(f32),
        #[prost(double, tag = "4")]
        DoubleValue(f64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Uuid {
    #[prost(bytes = "vec", tag = "1")]
    pub uuid_value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    #[prost(oneof = "value::ValueOf", tags = "1, 2, 3, 4, 5, 8, 9, 10, 11")]
    pub value_of: ::core::option::Option<value::ValueOf>,
}
/// Nested message and enum types in `value`.
pub mod value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ValueOf {
        #[prost(bool, tag = "1")]
        BoolValue(bool),
        #[prost(string, tag = "2")]
        StringValue(::prost::alloc::string::String),
        /// byte
        #[prost(bytes, tag = "3")]
        BytesValue(::prost::alloc::vec::Vec<u8>),
        /// uuid
        #[prost(message, tag = "4")]
        UuidValue(super::Uuid),
        #[prost(message, tag = "5")]
        NumberValue(super::Number),
        #[prost(message, tag = "8")]
        DateTimeValue(super::DateTime),
        #[prost(message, tag = "9")]
        DateValue(super::Date),
        #[prost(message, tag = "10")]
        DateRangeValue(super::DateRange),
        #[prost(message, tag = "11")]
        ArrayValues(super::ArrayValue),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArrayValue {
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<Value>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ValueType {
    Unknown = 0,
    Bool = 1,
    String = 2,
    Bytes = 3,
    Uuid = 4,
    Number = 5,
    Datetime = 6,
    Date = 7,
    DateRange = 8,
    ArrayValues = 10,
}
impl ValueType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ValueType::Unknown => "VALUE_TYPE_UNKNOWN",
            ValueType::Bool => "VALUE_TYPE_BOOL",
            ValueType::String => "VALUE_TYPE_STRING",
            ValueType::Bytes => "VALUE_TYPE_BYTES",
            ValueType::Uuid => "VALUE_TYPE_UUID",
            ValueType::Number => "VALUE_TYPE_NUMBER",
            ValueType::Datetime => "VALUE_TYPE_DATETIME",
            ValueType::Date => "VALUE_TYPE_DATE",
            ValueType::DateRange => "VALUE_TYPE_DATE_RANGE",
            ValueType::ArrayValues => "VALUE_TYPE_ARRAY_VALUES",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VALUE_TYPE_UNKNOWN" => Some(Self::Unknown),
            "VALUE_TYPE_BOOL" => Some(Self::Bool),
            "VALUE_TYPE_STRING" => Some(Self::String),
            "VALUE_TYPE_BYTES" => Some(Self::Bytes),
            "VALUE_TYPE_UUID" => Some(Self::Uuid),
            "VALUE_TYPE_NUMBER" => Some(Self::Number),
            "VALUE_TYPE_DATETIME" => Some(Self::Datetime),
            "VALUE_TYPE_DATE" => Some(Self::Date),
            "VALUE_TYPE_DATE_RANGE" => Some(Self::DateRange),
            "VALUE_TYPE_ARRAY_VALUES" => Some(Self::ArrayValues),
            _ => None,
        }
    }
}
